# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateDepartment {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
}

type AggregateEmployee {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
}

type AggregateInventory {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
}

type AggregateProduct {
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
}

type AggregateProductSale {
  _avg: ProductSaleAvgAggregate
  _count: ProductSaleCountAggregate
  _max: ProductSaleMaxAggregate
  _min: ProductSaleMinAggregate
  _sum: ProductSaleSumAggregate
}

type AggregateRole {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
}

type AggregateSize {
  _count: SizeCountAggregate
  _max: SizeMaxAggregate
  _min: SizeMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Customer {
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerCountAggregate {
  _all: Int!
  city: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
  state: Int!
  streetAddress: Int!
  zipCode: Int!
}

input CustomerCountOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerCreateInput {
  city: String!
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerMaxAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerMaxOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type CustomerMinAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerMinOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByWithRelationInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum CustomerScalarFieldEnum {
  city
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
  state
  streetAddress
  zipCode
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  state: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerUpdateManyMutationInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input CustomerWhereUniqueInput {
  email: String
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Department {
  _count: DepartmentCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  id: String!
  name: String!
}

type DepartmentCount {
  employees: Int!
}

type DepartmentCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input DepartmentCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeCreateNestedManyWithoutDepartmentInput
  id: String
  name: String!
}

input DepartmentCreateNestedOneWithoutEmployeesInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
}

input DepartmentCreateOrConnectWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  where: DepartmentWhereUniqueInput!
}

input DepartmentCreateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
}

type DepartmentGroupBy {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type DepartmentMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type DepartmentMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithAggregationInput {
  _count: DepartmentCountOrderByAggregateInput
  _max: DepartmentMaxOrderByAggregateInput
  _min: DepartmentMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  employees: EmployeeOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

input DepartmentRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

enum DepartmentScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input DepartmentScalarWhereWithAggregatesInput {
  AND: [DepartmentScalarWhereWithAggregatesInput!]
  NOT: [DepartmentScalarWhereWithAggregatesInput!]
  OR: [DepartmentScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input DepartmentUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeUpdateManyWithoutDepartmentNestedInput
  id: String
  name: String
}

input DepartmentUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpdateOneRequiredWithoutEmployeesNestedInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
  update: DepartmentUpdateWithoutEmployeesInput
  upsert: DepartmentUpsertWithoutEmployeesInput
}

input DepartmentUpdateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpsertWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  update: DepartmentUpdateWithoutEmployeesInput!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  name: StringFilter
}

input DepartmentWhereUniqueInput {
  id: String
  name: String
}

type Employee {
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  department: Department!
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeCountAggregate {
  _all: Int!
  city: Int!
  dateStarted: Int!
  dateUpdated: Int!
  departmentId: Int!
  email: Int!
  firstName: Int!
  gender: Int!
  id: Int!
  jobTitle: Int!
  lastName: Int!
  phone: Int!
  state: Int!
  streetAddress: Int!
  zipCode: Int!
}

input EmployeeCountOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeCreateInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentCreateNestedOneWithoutEmployeesInput!
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeCreateNestedManyWithoutDepartmentInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
}

input EmployeeCreateOrConnectWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateWithoutDepartmentInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeGroupBy {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeeMaxAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeMaxOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type EmployeeMinAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeMinOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByRelationAggregateInput {
  _count: SortOrder
}

input EmployeeOrderByWithAggregationInput {
  _count: EmployeeCountOrderByAggregateInput
  _max: EmployeeMaxOrderByAggregateInput
  _min: EmployeeMinOrderByAggregateInput
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByWithRelationInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  department: DepartmentOrderByWithRelationInput
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum EmployeeScalarFieldEnum {
  city
  dateStarted
  dateUpdated
  departmentId
  email
  firstName
  gender
  id
  jobTitle
  lastName
  phone
  state
  streetAddress
  zipCode
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput!]
  NOT: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeScalarWhereWithAggregatesInput {
  AND: [EmployeeScalarWhereWithAggregatesInput!]
  NOT: [EmployeeScalarWhereWithAggregatesInput!]
  OR: [EmployeeScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateStarted: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  departmentId: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  jobTitle: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  state: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input EmployeeUpdateInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentUpdateOneRequiredWithoutEmployeesNestedInput
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyMutationInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyWithWhereWithoutDepartmentInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithoutDepartmentNestedInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutDepartmentInput!]
  updateMany: [EmployeeUpdateManyWithWhereWithoutDepartmentInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutDepartmentInput!]
}

input EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  data: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithoutDepartmentInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  update: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  department: DepartmentRelationFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeWhereUniqueInput {
  email: String
  id: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Inventory {
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: Size!
  sizeId: String!
}

type InventoryAvgAggregate {
  quantity: Float
}

input InventoryAvgOrderByAggregateInput {
  quantity: SortOrder
}

type InventoryCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
  quantity: Int!
  sizeId: Int!
}

input InventoryCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutInventoryInput!
  quantity: Int!
  size: SizeCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateNestedManyWithoutProductInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
}

input InventoryCreateNestedManyWithoutSizeInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutSizeInput!]
  create: [InventoryCreateWithoutSizeInput!]
}

input InventoryCreateOrConnectWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateOrConnectWithoutSizeInput {
  create: InventoryCreateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int!
  size: SizeCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutInventoryInput!
  quantity: Int!
}

type InventoryGroupBy {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  productId: String!
  quantity: Int!
  sizeId: String!
}

input InventoryListRelationFilter {
  every: InventoryWhereInput
  none: InventoryWhereInput
  some: InventoryWhereInput
}

type InventoryMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input InventoryMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

type InventoryMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input InventoryMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input InventoryOrderByWithAggregationInput {
  _avg: InventoryAvgOrderByAggregateInput
  _count: InventoryCountOrderByAggregateInput
  _max: InventoryMaxOrderByAggregateInput
  _min: InventoryMinOrderByAggregateInput
  _sum: InventorySumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SizeOrderByWithRelationInput
  sizeId: SortOrder
}

enum InventoryScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  productId
  quantity
  sizeId
}

input InventoryScalarWhereInput {
  AND: [InventoryScalarWhereInput!]
  NOT: [InventoryScalarWhereInput!]
  OR: [InventoryScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  productId: StringFilter
  quantity: IntFilter
  sizeId: StringFilter
}

input InventoryScalarWhereWithAggregatesInput {
  AND: [InventoryScalarWhereWithAggregatesInput!]
  NOT: [InventoryScalarWhereWithAggregatesInput!]
  OR: [InventoryScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  sizeId: StringWithAggregatesFilter
}

type InventorySumAggregate {
  quantity: Int
}

input InventorySumOrderByAggregateInput {
  quantity: SortOrder
}

input InventoryUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutInventoryNestedInput
  quantity: Int
  size: SizeUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
}

input InventoryUpdateManyWithWhereWithoutProductInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithWhereWithoutSizeInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithoutProductNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutProductInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutProductInput!]
}

input InventoryUpdateManyWithoutSizeNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutSizeInput!]
  create: [InventoryCreateWithoutSizeInput!]
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutSizeInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutSizeInput!]
}

input InventoryUpdateWithWhereUniqueWithoutProductInput {
  data: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithWhereUniqueWithoutSizeInput {
  data: InventoryUpdateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
  size: SizeUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutInventoryNestedInput
  quantity: Int
}

input InventoryUpsertWithWhereUniqueWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  update: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpsertWithWhereUniqueWithoutSizeInput {
  create: InventoryCreateWithoutSizeInput!
  update: InventoryUpdateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryWhereInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: SizeRelationFilter
  sizeId: StringFilter
}

input InventoryWhereUniqueInput {
  id: String
}

type Mutation {
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneDepartment(data: DepartmentCreateInput!): Department!
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneInventory(data: InventoryCreateInput!): Inventory!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneProductSale(data: ProductSaleCreateInput!): ProductSale!
  createOneRole(data: RoleCreateInput!): Role!
  createOneSize(data: SizeCreateInput!): Size!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyDepartment(where: DepartmentWhereInput): AffectedRowsOutput!
  deleteManyEmployee(where: EmployeeWhereInput): AffectedRowsOutput!
  deleteManyInventory(where: InventoryWhereInput): AffectedRowsOutput!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyProductSale(where: ProductSaleWhereInput): AffectedRowsOutput!
  deleteManyRole(where: RoleWhereInput): AffectedRowsOutput!
  deleteManySize(where: SizeWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteOneEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteOneInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneProductSale(where: ProductSaleWhereUniqueInput!): ProductSale
  deleteOneRole(where: RoleWhereUniqueInput!): Role
  deleteOneSize(where: SizeWhereUniqueInput!): Size
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyDepartment(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): AffectedRowsOutput!
  updateManyEmployee(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): AffectedRowsOutput!
  updateManyInventory(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): AffectedRowsOutput!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyProductSale(data: ProductSaleUpdateManyMutationInput!, where: ProductSaleWhereInput): AffectedRowsOutput!
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): AffectedRowsOutput!
  updateManySize(data: SizeUpdateManyMutationInput!, where: SizeWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateOneProductSale(data: ProductSaleUpdateInput!, where: ProductSaleWhereUniqueInput!): ProductSale
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateOneSize(data: SizeUpdateInput!, where: SizeWhereUniqueInput!): Size
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneDepartment(create: DepartmentCreateInput!, update: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department!
  upsertOneEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOneInventory(create: InventoryCreateInput!, update: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory!
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneProductSale(create: ProductSaleCreateInput!, update: ProductSaleUpdateInput!, where: ProductSaleWhereUniqueInput!): ProductSale!
  upsertOneRole(create: RoleCreateInput!, update: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  upsertOneSize(create: SizeCreateInput!, update: SizeUpdateInput!, where: SizeWhereUniqueInput!): Size!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Product {
  _count: ProductCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  name: String!
  productSale(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
}

type ProductCount {
  inventory: Int!
  productSale: Int!
}

type ProductCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input ProductCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ProductCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutProductInput
  name: String!
  productSale: ProductSaleCreateNestedManyWithoutProductInput
}

input ProductCreateNestedOneWithoutInventoryInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
}

input ProductCreateNestedOneWithoutProductSaleInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSaleInput
  create: ProductCreateWithoutProductSaleInput
}

input ProductCreateOrConnectWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductSaleInput {
  create: ProductCreateWithoutProductSaleInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
  productSale: ProductSaleCreateNestedManyWithoutProductInput
}

input ProductCreateWithoutProductSaleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutProductInput
  name: String!
}

type ProductGroupBy {
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type ProductMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input ProductMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type ProductMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input ProductMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ProductOrderByWithAggregationInput {
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ProductOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  inventory: InventoryOrderByRelationAggregateInput
  name: SortOrder
  productSale: ProductSaleOrderByRelationAggregateInput
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

type ProductSale {
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: Size!
  sizeId: String!
}

type ProductSaleAvgAggregate {
  quantity: Float
}

input ProductSaleAvgOrderByAggregateInput {
  quantity: SortOrder
}

type ProductSaleCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
  quantity: Int!
  sizeId: Int!
}

input ProductSaleCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutProductSaleInput!
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductSaleInput!
}

input ProductSaleCreateNestedManyWithoutProductInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutProductInput!]
  create: [ProductSaleCreateWithoutProductInput!]
}

input ProductSaleCreateNestedManyWithoutSizeInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutSizeInput!]
  create: [ProductSaleCreateWithoutSizeInput!]
}

input ProductSaleCreateOrConnectWithoutProductInput {
  create: ProductSaleCreateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleCreateOrConnectWithoutSizeInput {
  create: ProductSaleCreateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleCreateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductSaleInput!
}

input ProductSaleCreateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutProductSaleInput!
  quantity: Int!
}

type ProductSaleGroupBy {
  _avg: ProductSaleAvgAggregate
  _count: ProductSaleCountAggregate
  _max: ProductSaleMaxAggregate
  _min: ProductSaleMinAggregate
  _sum: ProductSaleSumAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  productId: String!
  quantity: Int!
  sizeId: String!
}

input ProductSaleListRelationFilter {
  every: ProductSaleWhereInput
  none: ProductSaleWhereInput
  some: ProductSaleWhereInput
}

type ProductSaleMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input ProductSaleMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

type ProductSaleMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input ProductSaleMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductSaleOrderByWithAggregationInput {
  _avg: ProductSaleAvgOrderByAggregateInput
  _count: ProductSaleCountOrderByAggregateInput
  _max: ProductSaleMaxOrderByAggregateInput
  _min: ProductSaleMinOrderByAggregateInput
  _sum: ProductSaleSumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SizeOrderByWithRelationInput
  sizeId: SortOrder
}

enum ProductSaleScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  productId
  quantity
  sizeId
}

input ProductSaleScalarWhereInput {
  AND: [ProductSaleScalarWhereInput!]
  NOT: [ProductSaleScalarWhereInput!]
  OR: [ProductSaleScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  productId: StringFilter
  quantity: IntFilter
  sizeId: StringFilter
}

input ProductSaleScalarWhereWithAggregatesInput {
  AND: [ProductSaleScalarWhereWithAggregatesInput!]
  NOT: [ProductSaleScalarWhereWithAggregatesInput!]
  OR: [ProductSaleScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  sizeId: StringWithAggregatesFilter
}

type ProductSaleSumAggregate {
  quantity: Int
}

input ProductSaleSumOrderByAggregateInput {
  quantity: SortOrder
}

input ProductSaleUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutProductSaleNestedInput
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductSaleNestedInput
}

input ProductSaleUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
}

input ProductSaleUpdateManyWithWhereWithoutProductInput {
  data: ProductSaleUpdateManyMutationInput!
  where: ProductSaleScalarWhereInput!
}

input ProductSaleUpdateManyWithWhereWithoutSizeInput {
  data: ProductSaleUpdateManyMutationInput!
  where: ProductSaleScalarWhereInput!
}

input ProductSaleUpdateManyWithoutProductNestedInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutProductInput!]
  create: [ProductSaleCreateWithoutProductInput!]
  delete: [ProductSaleWhereUniqueInput!]
  deleteMany: [ProductSaleScalarWhereInput!]
  disconnect: [ProductSaleWhereUniqueInput!]
  set: [ProductSaleWhereUniqueInput!]
  update: [ProductSaleUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductSaleUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductSaleUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductSaleUpdateManyWithoutSizeNestedInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutSizeInput!]
  create: [ProductSaleCreateWithoutSizeInput!]
  delete: [ProductSaleWhereUniqueInput!]
  deleteMany: [ProductSaleScalarWhereInput!]
  disconnect: [ProductSaleWhereUniqueInput!]
  set: [ProductSaleWhereUniqueInput!]
  update: [ProductSaleUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [ProductSaleUpdateManyWithWhereWithoutSizeInput!]
  upsert: [ProductSaleUpsertWithWhereUniqueWithoutSizeInput!]
}

input ProductSaleUpdateWithWhereUniqueWithoutProductInput {
  data: ProductSaleUpdateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpdateWithWhereUniqueWithoutSizeInput {
  data: ProductSaleUpdateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpdateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductSaleNestedInput
}

input ProductSaleUpdateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutProductSaleNestedInput
  quantity: Int
}

input ProductSaleUpsertWithWhereUniqueWithoutProductInput {
  create: ProductSaleCreateWithoutProductInput!
  update: ProductSaleUpdateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpsertWithWhereUniqueWithoutSizeInput {
  create: ProductSaleCreateWithoutSizeInput!
  update: ProductSaleUpdateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleWhereInput {
  AND: [ProductSaleWhereInput!]
  NOT: [ProductSaleWhereInput!]
  OR: [ProductSaleWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: SizeRelationFilter
  sizeId: StringFilter
}

input ProductSaleWhereUniqueInput {
  id: String
}

enum ProductScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input ProductUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutProductNestedInput
  name: String
  productSale: ProductSaleUpdateManyWithoutProductNestedInput
}

input ProductUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input ProductUpdateOneRequiredWithoutInventoryNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
  update: ProductUpdateWithoutInventoryInput
  upsert: ProductUpsertWithoutInventoryInput
}

input ProductUpdateOneRequiredWithoutProductSaleNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSaleInput
  create: ProductCreateWithoutProductSaleInput
  update: ProductUpdateWithoutProductSaleInput
  upsert: ProductUpsertWithoutProductSaleInput
}

input ProductUpdateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  productSale: ProductSaleUpdateManyWithoutProductNestedInput
}

input ProductUpdateWithoutProductSaleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutProductNestedInput
  name: String
}

input ProductUpsertWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  update: ProductUpdateWithoutInventoryInput!
}

input ProductUpsertWithoutProductSaleInput {
  create: ProductCreateWithoutProductSaleInput!
  update: ProductUpdateWithoutProductSaleInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  inventory: InventoryListRelationFilter
  name: StringFilter
  productSale: ProductSaleListRelationFilter
}

input ProductWhereUniqueInput {
  id: String
  name: String
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateDepartment(cursor: DepartmentWhereUniqueInput, orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): AggregateDepartment!
  aggregateEmployee(cursor: EmployeeWhereUniqueInput, orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): AggregateEmployee!
  aggregateInventory(cursor: InventoryWhereUniqueInput, orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): AggregateInventory!
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateProductSale(cursor: ProductSaleWhereUniqueInput, orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): AggregateProductSale!
  aggregateRole(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): AggregateRole!
  aggregateSize(cursor: SizeWhereUniqueInput, orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): AggregateSize!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [Department!]!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstDepartment(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstDepartmentOrThrow(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstEmployee(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstEmployeeOrThrow(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstInventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstInventoryOrThrow(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductOrThrow(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductSale(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): ProductSale
  findFirstProductSaleOrThrow(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): ProductSale
  findFirstRole(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstRoleOrThrow(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstSize(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): Size
  findFirstSizeOrThrow(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): Size
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getDepartment(where: DepartmentWhereUniqueInput!): Department
  getEmployee(where: EmployeeWhereUniqueInput!): Employee
  getInventory(where: InventoryWhereUniqueInput!): Inventory
  getProduct(where: ProductWhereUniqueInput!): Product
  getProductSale(where: ProductSaleWhereUniqueInput!): ProductSale
  getRole(where: RoleWhereUniqueInput!): Role
  getSize(where: SizeWhereUniqueInput!): Size
  getUser(where: UserWhereUniqueInput!): User
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByDepartment(by: [DepartmentScalarFieldEnum!]!, having: DepartmentScalarWhereWithAggregatesInput, orderBy: [DepartmentOrderByWithAggregationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [DepartmentGroupBy!]!
  groupByEmployee(by: [EmployeeScalarFieldEnum!]!, having: EmployeeScalarWhereWithAggregatesInput, orderBy: [EmployeeOrderByWithAggregationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [EmployeeGroupBy!]!
  groupByInventory(by: [InventoryScalarFieldEnum!]!, having: InventoryScalarWhereWithAggregatesInput, orderBy: [InventoryOrderByWithAggregationInput!], skip: Int, take: Int, where: InventoryWhereInput): [InventoryGroupBy!]!
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByProductSale(by: [ProductSaleScalarFieldEnum!]!, having: ProductSaleScalarWhereWithAggregatesInput, orderBy: [ProductSaleOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSaleGroupBy!]!
  groupByRole(by: [RoleScalarFieldEnum!]!, having: RoleScalarWhereWithAggregatesInput, orderBy: [RoleOrderByWithAggregationInput!], skip: Int, take: Int, where: RoleWhereInput): [RoleGroupBy!]!
  groupBySize(by: [SizeScalarFieldEnum!]!, having: SizeScalarWhereWithAggregatesInput, orderBy: [SizeOrderByWithAggregationInput!], skip: Int, take: Int, where: SizeWhereInput): [SizeGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  inventories(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  login(password: String!, userName: String!): String
  product(where: ProductWhereUniqueInput!): Product
  productSale(where: ProductSaleWhereUniqueInput!): ProductSale
  productSales(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  role(where: RoleWhereUniqueInput!): Role
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  size(where: SizeWhereUniqueInput!): Size
  sizes(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): [Size!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Role {
  _count: RoleCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  description: Int!
  id: Int!
  name: Int!
}

input RoleCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
  users: UserCreateNestedManyWithoutRoleInput
}

input RoleCreateNestedOneWithoutUsersInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
}

type RoleGroupBy {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
}

type RoleMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

type RoleMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithAggregationInput {
  _count: RoleCountOrderByAggregateInput
  _max: RoleMaxOrderByAggregateInput
  _min: RoleMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  users: UserOrderByRelationAggregateInput
}

input RoleRelationFilter {
  is: RoleWhereInput
  isNot: RoleWhereInput
}

enum RoleScalarFieldEnum {
  dateCreated
  dateUpdated
  description
  id
  name
}

input RoleScalarWhereWithAggregatesInput {
  AND: [RoleScalarWhereWithAggregatesInput!]
  NOT: [RoleScalarWhereWithAggregatesInput!]
  OR: [RoleScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input RoleUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
  users: UserUpdateManyWithoutRoleNestedInput
}

input RoleUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpdateOneRequiredWithoutUsersNestedInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
  update: RoleUpdateWithoutUsersInput
  upsert: RoleUpsertWithoutUsersInput
}

input RoleUpdateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpsertWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  update: RoleUpdateWithoutUsersInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

type Size {
  _count: SizeCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  name: String!
  productSale(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
}

type SizeCount {
  inventory: Int!
  productSale: Int!
}

type SizeCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input SizeCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutSizeInput
  name: String!
  productSale: ProductSaleCreateNestedManyWithoutSizeInput
}

input SizeCreateNestedOneWithoutInventoryInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutInventoryInput
  create: SizeCreateWithoutInventoryInput
}

input SizeCreateNestedOneWithoutProductSaleInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductSaleInput
  create: SizeCreateWithoutProductSaleInput
}

input SizeCreateOrConnectWithoutInventoryInput {
  create: SizeCreateWithoutInventoryInput!
  where: SizeWhereUniqueInput!
}

input SizeCreateOrConnectWithoutProductSaleInput {
  create: SizeCreateWithoutProductSaleInput!
  where: SizeWhereUniqueInput!
}

input SizeCreateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
  productSale: ProductSaleCreateNestedManyWithoutSizeInput
}

input SizeCreateWithoutProductSaleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutSizeInput
  name: String!
}

type SizeGroupBy {
  _count: SizeCountAggregate
  _max: SizeMaxAggregate
  _min: SizeMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type SizeMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type SizeMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeOrderByWithAggregationInput {
  _count: SizeCountOrderByAggregateInput
  _max: SizeMaxOrderByAggregateInput
  _min: SizeMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  inventory: InventoryOrderByRelationAggregateInput
  name: SortOrder
  productSale: ProductSaleOrderByRelationAggregateInput
}

input SizeRelationFilter {
  is: SizeWhereInput
  isNot: SizeWhereInput
}

enum SizeScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input SizeScalarWhereWithAggregatesInput {
  AND: [SizeScalarWhereWithAggregatesInput!]
  NOT: [SizeScalarWhereWithAggregatesInput!]
  OR: [SizeScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input SizeUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutSizeNestedInput
  name: String
  productSale: ProductSaleUpdateManyWithoutSizeNestedInput
}

input SizeUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeUpdateOneRequiredWithoutInventoryNestedInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutInventoryInput
  create: SizeCreateWithoutInventoryInput
  update: SizeUpdateWithoutInventoryInput
  upsert: SizeUpsertWithoutInventoryInput
}

input SizeUpdateOneRequiredWithoutProductSaleNestedInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductSaleInput
  create: SizeCreateWithoutProductSaleInput
  update: SizeUpdateWithoutProductSaleInput
  upsert: SizeUpsertWithoutProductSaleInput
}

input SizeUpdateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  productSale: ProductSaleUpdateManyWithoutSizeNestedInput
}

input SizeUpdateWithoutProductSaleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutSizeNestedInput
  name: String
}

input SizeUpsertWithoutInventoryInput {
  create: SizeCreateWithoutInventoryInput!
  update: SizeUpdateWithoutInventoryInput!
}

input SizeUpsertWithoutProductSaleInput {
  create: SizeCreateWithoutProductSaleInput!
  update: SizeUpdateWithoutProductSaleInput!
}

input SizeWhereInput {
  AND: [SizeWhereInput!]
  NOT: [SizeWhereInput!]
  OR: [SizeWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  inventory: InventoryListRelationFilter
  name: StringFilter
  productSale: ProductSaleListRelationFilter
}

input SizeWhereUniqueInput {
  id: String
  name: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  role: Role!
  roleId: String!
  userName: String!
}

type UserCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  roleId: Int!
  userName: Int!
}

input UserCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: RoleCreateNestedOneWithoutUsersInput!
  userName: String!
}

input UserCreateNestedManyWithoutRoleInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
}

input UserCreateOrConnectWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  userName: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  roleId: String!
  userName: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

type UserMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: RoleOrderByWithRelationInput
  roleId: SortOrder
  userName: SortOrder
}

enum UserScalarFieldEnum {
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  password
  roleId
  userName
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  roleId: StringWithAggregatesFilter
  userName: StringWithAggregatesFilter
}

input UserUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: RoleUpdateOneRequiredWithoutUsersNestedInput
  userName: String
}

input UserUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpdateManyWithWhereWithoutRoleInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutRoleNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [UserUpdateManyWithWhereWithoutRoleInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserUpdateWithWhereUniqueWithoutRoleInput {
  data: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpsertWithWhereUniqueWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  update: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  role: RoleRelationFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  userName: String
}