# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateDepartment {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
}

type AggregateEmployee {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
}

type AggregateInventory {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
}

type AggregateLocationState {
  _count: LocationStateCountAggregate
  _max: LocationStateMaxAggregate
  _min: LocationStateMinAggregate
}

type AggregateProduct {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
}

type AggregateProductSale {
  _avg: ProductSaleAvgAggregate
  _count: ProductSaleCountAggregate
  _max: ProductSaleMaxAggregate
  _min: ProductSaleMinAggregate
  _sum: ProductSaleSumAggregate
}

type AggregateProductTransaction {
  _avg: ProductTransactionAvgAggregate
  _count: ProductTransactionCountAggregate
  _max: ProductTransactionMaxAggregate
  _min: ProductTransactionMinAggregate
  _sum: ProductTransactionSumAggregate
}

type AggregateRole {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
}

type AggregateSize {
  _count: SizeCountAggregate
  _max: SizeMaxAggregate
  _min: SizeMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Customer {
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  locationState: LocationState
  phone: String!
  stateId: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerCountAggregate {
  _all: Int!
  city: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
  stateId: Int!
  streetAddress: Int!
  zipCode: Int!
}

input CustomerCountOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerCreateInput {
  city: String!
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  locationState: LocationStateCreateNestedOneWithoutCustomersInput
  phone: String!
  streetAddress: String!
  zipCode: String!
}

input CustomerCreateNestedManyWithoutLocationStateInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutLocationStateInput!]
  create: [CustomerCreateWithoutLocationStateInput!]
}

input CustomerCreateOrConnectWithoutLocationStateInput {
  create: CustomerCreateWithoutLocationStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutLocationStateInput {
  city: String!
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  zipCode: String!
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  zipCode: String
}

input CustomerMaxOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type CustomerMinAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  zipCode: String
}

input CustomerMinOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByWithRelationInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  locationState: LocationStateOrderByWithRelationInput
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum CustomerScalarFieldEnum {
  city
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
  stateId
  streetAddress
  zipCode
}

input CustomerScalarWhereInput {
  AND: [CustomerScalarWhereInput!]
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  stateId: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  locationState: LocationStateUpdateOneWithoutCustomersNestedInput
  phone: String
  streetAddress: String
  zipCode: String
}

input CustomerUpdateManyMutationInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  streetAddress: String
  zipCode: String
}

input CustomerUpdateManyWithWhereWithoutLocationStateInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithoutLocationStateNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutLocationStateInput!]
  create: [CustomerCreateWithoutLocationStateInput!]
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutLocationStateInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutLocationStateInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutLocationStateInput!]
}

input CustomerUpdateWithWhereUniqueWithoutLocationStateInput {
  data: CustomerUpdateWithoutLocationStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithoutLocationStateInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  streetAddress: String
  zipCode: String
}

input CustomerUpsertWithWhereUniqueWithoutLocationStateInput {
  create: CustomerCreateWithoutLocationStateInput!
  update: CustomerUpdateWithoutLocationStateInput!
  where: CustomerWhereUniqueInput!
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  locationState: LocationStateRelationFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input CustomerWhereUniqueInput {
  email: String
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Department {
  _count: DepartmentCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  id: String!
  name: String!
}

type DepartmentCount {
  employees: Int!
}

type DepartmentCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input DepartmentCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeCreateNestedManyWithoutDepartmentInput
  id: String
  name: String!
}

input DepartmentCreateNestedOneWithoutEmployeesInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
}

input DepartmentCreateOrConnectWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  where: DepartmentWhereUniqueInput!
}

input DepartmentCreateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
}

type DepartmentGroupBy {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type DepartmentMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type DepartmentMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithAggregationInput {
  _count: DepartmentCountOrderByAggregateInput
  _max: DepartmentMaxOrderByAggregateInput
  _min: DepartmentMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  employees: EmployeeOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

input DepartmentRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

enum DepartmentScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input DepartmentScalarWhereWithAggregatesInput {
  AND: [DepartmentScalarWhereWithAggregatesInput!]
  NOT: [DepartmentScalarWhereWithAggregatesInput!]
  OR: [DepartmentScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input DepartmentUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeUpdateManyWithoutDepartmentNestedInput
  id: String
  name: String
}

input DepartmentUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpdateOneRequiredWithoutEmployeesNestedInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
  update: DepartmentUpdateWithoutEmployeesInput
  upsert: DepartmentUpsertWithoutEmployeesInput
}

input DepartmentUpdateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpsertWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  update: DepartmentUpdateWithoutEmployeesInput!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  name: StringFilter
}

input DepartmentWhereUniqueInput {
  id: String
  name: String
}

type Employee {
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  department: Department!
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  locationState: LocationState!
  phone: String!
  stateId: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeCountAggregate {
  _all: Int!
  city: Int!
  dateStarted: Int!
  dateUpdated: Int!
  departmentId: Int!
  email: Int!
  firstName: Int!
  gender: Int!
  id: Int!
  jobTitle: Int!
  lastName: Int!
  phone: Int!
  stateId: Int!
  streetAddress: Int!
  zipCode: Int!
}

input EmployeeCountOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeCreateInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentCreateNestedOneWithoutEmployeesInput!
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  locationState: LocationStateCreateNestedOneWithoutEmployeesInput!
  phone: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeCreateNestedManyWithoutDepartmentInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
}

input EmployeeCreateNestedManyWithoutLocationStateInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutLocationStateInput!]
  create: [EmployeeCreateWithoutLocationStateInput!]
}

input EmployeeCreateOrConnectWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateOrConnectWithoutLocationStateInput {
  create: EmployeeCreateWithoutLocationStateInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateWithoutDepartmentInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  locationState: LocationStateCreateNestedOneWithoutEmployeesInput!
  phone: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeCreateWithoutLocationStateInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentCreateNestedOneWithoutEmployeesInput!
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  phone: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeGroupBy {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  phone: String!
  stateId: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeeMaxAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  zipCode: String
}

input EmployeeMaxOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type EmployeeMinAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  stateId: String
  streetAddress: String
  zipCode: String
}

input EmployeeMinOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByRelationAggregateInput {
  _count: SortOrder
}

input EmployeeOrderByWithAggregationInput {
  _count: EmployeeCountOrderByAggregateInput
  _max: EmployeeMaxOrderByAggregateInput
  _min: EmployeeMinOrderByAggregateInput
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByWithRelationInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  department: DepartmentOrderByWithRelationInput
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  locationState: LocationStateOrderByWithRelationInput
  phone: SortOrder
  stateId: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum EmployeeScalarFieldEnum {
  city
  dateStarted
  dateUpdated
  departmentId
  email
  firstName
  gender
  id
  jobTitle
  lastName
  phone
  stateId
  streetAddress
  zipCode
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput!]
  NOT: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeScalarWhereWithAggregatesInput {
  AND: [EmployeeScalarWhereWithAggregatesInput!]
  NOT: [EmployeeScalarWhereWithAggregatesInput!]
  OR: [EmployeeScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateStarted: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  departmentId: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  jobTitle: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  stateId: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input EmployeeUpdateInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentUpdateOneRequiredWithoutEmployeesNestedInput
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  locationState: LocationStateUpdateOneRequiredWithoutEmployeesNestedInput
  phone: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyMutationInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyWithWhereWithoutDepartmentInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithWhereWithoutLocationStateInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithoutDepartmentNestedInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutDepartmentInput!]
  updateMany: [EmployeeUpdateManyWithWhereWithoutDepartmentInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutDepartmentInput!]
}

input EmployeeUpdateManyWithoutLocationStateNestedInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutLocationStateInput!]
  create: [EmployeeCreateWithoutLocationStateInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutLocationStateInput!]
  updateMany: [EmployeeUpdateManyWithWhereWithoutLocationStateInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutLocationStateInput!]
}

input EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  data: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithWhereUniqueWithoutLocationStateInput {
  data: EmployeeUpdateWithoutLocationStateInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithoutDepartmentInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  locationState: LocationStateUpdateOneRequiredWithoutEmployeesNestedInput
  phone: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateWithoutLocationStateInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentUpdateOneRequiredWithoutEmployeesNestedInput
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  update: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithWhereUniqueWithoutLocationStateInput {
  create: EmployeeCreateWithoutLocationStateInput!
  update: EmployeeUpdateWithoutLocationStateInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  department: DepartmentRelationFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  locationState: LocationStateRelationFilter
  phone: StringFilter
  stateId: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeWhereUniqueInput {
  email: String
  id: String
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Inventory {
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: Size!
  sizeId: String!
}

type InventoryAvgAggregate {
  quantity: Float
}

input InventoryAvgOrderByAggregateInput {
  quantity: SortOrder
}

type InventoryCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
  quantity: Int!
  sizeId: Int!
}

input InventoryCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutInventoryInput!
  quantity: Int!
  size: SizeCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateNestedManyWithoutProductInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
}

input InventoryCreateNestedManyWithoutSizeInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutSizeInput!]
  create: [InventoryCreateWithoutSizeInput!]
}

input InventoryCreateOrConnectWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateOrConnectWithoutSizeInput {
  create: InventoryCreateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int!
  size: SizeCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutInventoryInput!
  quantity: Int!
}

type InventoryGroupBy {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  productId: String!
  quantity: Int!
  sizeId: String!
}

input InventoryListRelationFilter {
  every: InventoryWhereInput
  none: InventoryWhereInput
  some: InventoryWhereInput
}

type InventoryMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input InventoryMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

type InventoryMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input InventoryMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input InventoryOrderByWithAggregationInput {
  _avg: InventoryAvgOrderByAggregateInput
  _count: InventoryCountOrderByAggregateInput
  _max: InventoryMaxOrderByAggregateInput
  _min: InventoryMinOrderByAggregateInput
  _sum: InventorySumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input InventoryOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SizeOrderByWithRelationInput
  sizeId: SortOrder
}

enum InventoryScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  productId
  quantity
  sizeId
}

input InventoryScalarWhereInput {
  AND: [InventoryScalarWhereInput!]
  NOT: [InventoryScalarWhereInput!]
  OR: [InventoryScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  productId: StringFilter
  quantity: IntFilter
  sizeId: StringFilter
}

input InventoryScalarWhereWithAggregatesInput {
  AND: [InventoryScalarWhereWithAggregatesInput!]
  NOT: [InventoryScalarWhereWithAggregatesInput!]
  OR: [InventoryScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  sizeId: StringWithAggregatesFilter
}

type InventorySumAggregate {
  quantity: Int
}

input InventorySumOrderByAggregateInput {
  quantity: SortOrder
}

input InventoryUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutInventoryNestedInput
  quantity: Int
  size: SizeUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
}

input InventoryUpdateManyWithWhereWithoutProductInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithWhereWithoutSizeInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithoutProductNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutProductInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutProductInput!]
}

input InventoryUpdateManyWithoutSizeNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutSizeInput!]
  create: [InventoryCreateWithoutSizeInput!]
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutSizeInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutSizeInput!]
}

input InventoryUpdateWithWhereUniqueWithoutProductInput {
  data: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithWhereUniqueWithoutSizeInput {
  data: InventoryUpdateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
  size: SizeUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutInventoryNestedInput
  quantity: Int
}

input InventoryUpsertWithWhereUniqueWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  update: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpsertWithWhereUniqueWithoutSizeInput {
  create: InventoryCreateWithoutSizeInput!
  update: InventoryUpdateWithoutSizeInput!
  where: InventoryWhereUniqueInput!
}

input InventoryWhereInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: SizeRelationFilter
  sizeId: StringFilter
}

input InventoryWhereUniqueInput {
  id: String
}

type LocationState {
  _count: LocationStateCount
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  dateCreated: DateTime!
  dateUpdated: DateTime
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  id: String!
  name: String!
  shortName: String!
}

type LocationStateCount {
  customers: Int!
  employees: Int!
}

type LocationStateCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
  shortName: Int!
}

input LocationStateCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  shortName: SortOrder
}

input LocationStateCreateInput {
  customers: CustomerCreateNestedManyWithoutLocationStateInput
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeCreateNestedManyWithoutLocationStateInput
  id: String
  name: String!
  shortName: String!
}

input LocationStateCreateNestedOneWithoutCustomersInput {
  connect: LocationStateWhereUniqueInput
  connectOrCreate: LocationStateCreateOrConnectWithoutCustomersInput
  create: LocationStateCreateWithoutCustomersInput
}

input LocationStateCreateNestedOneWithoutEmployeesInput {
  connect: LocationStateWhereUniqueInput
  connectOrCreate: LocationStateCreateOrConnectWithoutEmployeesInput
  create: LocationStateCreateWithoutEmployeesInput
}

input LocationStateCreateOrConnectWithoutCustomersInput {
  create: LocationStateCreateWithoutCustomersInput!
  where: LocationStateWhereUniqueInput!
}

input LocationStateCreateOrConnectWithoutEmployeesInput {
  create: LocationStateCreateWithoutEmployeesInput!
  where: LocationStateWhereUniqueInput!
}

input LocationStateCreateWithoutCustomersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeCreateNestedManyWithoutLocationStateInput
  id: String
  name: String!
  shortName: String!
}

input LocationStateCreateWithoutEmployeesInput {
  customers: CustomerCreateNestedManyWithoutLocationStateInput
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
  shortName: String!
}

type LocationStateGroupBy {
  _count: LocationStateCountAggregate
  _max: LocationStateMaxAggregate
  _min: LocationStateMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
  shortName: String!
}

type LocationStateMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  shortName: String
}

input LocationStateMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  shortName: SortOrder
}

type LocationStateMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  shortName: String
}

input LocationStateMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  shortName: SortOrder
}

input LocationStateOrderByWithAggregationInput {
  _count: LocationStateCountOrderByAggregateInput
  _max: LocationStateMaxOrderByAggregateInput
  _min: LocationStateMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  shortName: SortOrder
}

input LocationStateOrderByWithRelationInput {
  customers: CustomerOrderByRelationAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  employees: EmployeeOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  shortName: SortOrder
}

input LocationStateRelationFilter {
  is: LocationStateWhereInput
  isNot: LocationStateWhereInput
}

enum LocationStateScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
  shortName
}

input LocationStateScalarWhereWithAggregatesInput {
  AND: [LocationStateScalarWhereWithAggregatesInput!]
  NOT: [LocationStateScalarWhereWithAggregatesInput!]
  OR: [LocationStateScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  shortName: StringWithAggregatesFilter
}

input LocationStateUpdateInput {
  customers: CustomerUpdateManyWithoutLocationStateNestedInput
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeUpdateManyWithoutLocationStateNestedInput
  id: String
  name: String
  shortName: String
}

input LocationStateUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  shortName: String
}

input LocationStateUpdateOneRequiredWithoutEmployeesNestedInput {
  connect: LocationStateWhereUniqueInput
  connectOrCreate: LocationStateCreateOrConnectWithoutEmployeesInput
  create: LocationStateCreateWithoutEmployeesInput
  update: LocationStateUpdateWithoutEmployeesInput
  upsert: LocationStateUpsertWithoutEmployeesInput
}

input LocationStateUpdateOneWithoutCustomersNestedInput {
  connect: LocationStateWhereUniqueInput
  connectOrCreate: LocationStateCreateOrConnectWithoutCustomersInput
  create: LocationStateCreateWithoutCustomersInput
  delete: Boolean
  disconnect: Boolean
  update: LocationStateUpdateWithoutCustomersInput
  upsert: LocationStateUpsertWithoutCustomersInput
}

input LocationStateUpdateWithoutCustomersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeUpdateManyWithoutLocationStateNestedInput
  id: String
  name: String
  shortName: String
}

input LocationStateUpdateWithoutEmployeesInput {
  customers: CustomerUpdateManyWithoutLocationStateNestedInput
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  shortName: String
}

input LocationStateUpsertWithoutCustomersInput {
  create: LocationStateCreateWithoutCustomersInput!
  update: LocationStateUpdateWithoutCustomersInput!
}

input LocationStateUpsertWithoutEmployeesInput {
  create: LocationStateCreateWithoutEmployeesInput!
  update: LocationStateUpdateWithoutEmployeesInput!
}

input LocationStateWhereInput {
  AND: [LocationStateWhereInput!]
  NOT: [LocationStateWhereInput!]
  OR: [LocationStateWhereInput!]
  customers: CustomerListRelationFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  name: StringFilter
  shortName: StringFilter
}

input LocationStateWhereUniqueInput {
  id: String
  name: String
  shortName: String
}

type Mutation {
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneDepartment(data: DepartmentCreateInput!): Department!
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneInventory(data: InventoryCreateInput!): Inventory!
  createOneLocationState(data: LocationStateCreateInput!): LocationState!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneProductSale(data: ProductSaleCreateInput!): ProductSale!
  createOneProductTransaction(data: ProductTransactionCreateInput!): ProductTransaction!
  createOneRole(data: RoleCreateInput!): Role!
  createOneSize(data: SizeCreateInput!): Size!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyDepartment(where: DepartmentWhereInput): AffectedRowsOutput!
  deleteManyEmployee(where: EmployeeWhereInput): AffectedRowsOutput!
  deleteManyInventory(where: InventoryWhereInput): AffectedRowsOutput!
  deleteManyLocationState(where: LocationStateWhereInput): AffectedRowsOutput!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyProductSale(where: ProductSaleWhereInput): AffectedRowsOutput!
  deleteManyProductTransaction(where: ProductTransactionWhereInput): AffectedRowsOutput!
  deleteManyRole(where: RoleWhereInput): AffectedRowsOutput!
  deleteManySize(where: SizeWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteOneEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteOneInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteOneLocationState(where: LocationStateWhereUniqueInput!): LocationState
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneProductSale(where: ProductSaleWhereUniqueInput!): ProductSale
  deleteOneProductTransaction(where: ProductTransactionWhereUniqueInput!): ProductTransaction
  deleteOneRole(where: RoleWhereUniqueInput!): Role
  deleteOneSize(where: SizeWhereUniqueInput!): Size
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(password: String!, userName: String!): String
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyDepartment(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): AffectedRowsOutput!
  updateManyEmployee(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): AffectedRowsOutput!
  updateManyInventory(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): AffectedRowsOutput!
  updateManyLocationState(data: LocationStateUpdateManyMutationInput!, where: LocationStateWhereInput): AffectedRowsOutput!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyProductSale(data: ProductSaleUpdateManyMutationInput!, where: ProductSaleWhereInput): AffectedRowsOutput!
  updateManyProductTransaction(data: ProductTransactionUpdateManyMutationInput!, where: ProductTransactionWhereInput): AffectedRowsOutput!
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): AffectedRowsOutput!
  updateManySize(data: SizeUpdateManyMutationInput!, where: SizeWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateOneLocationState(data: LocationStateUpdateInput!, where: LocationStateWhereUniqueInput!): LocationState
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateOneProductSale(data: ProductSaleUpdateInput!, where: ProductSaleWhereUniqueInput!): ProductSale
  updateOneProductTransaction(data: ProductTransactionUpdateInput!, where: ProductTransactionWhereUniqueInput!): ProductTransaction
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateOneSize(data: SizeUpdateInput!, where: SizeWhereUniqueInput!): Size
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneDepartment(create: DepartmentCreateInput!, update: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department!
  upsertOneEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOneInventory(create: InventoryCreateInput!, update: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory!
  upsertOneLocationState(create: LocationStateCreateInput!, update: LocationStateUpdateInput!, where: LocationStateWhereUniqueInput!): LocationState!
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneProductSale(create: ProductSaleCreateInput!, update: ProductSaleUpdateInput!, where: ProductSaleWhereUniqueInput!): ProductSale!
  upsertOneProductTransaction(create: ProductTransactionCreateInput!, update: ProductTransactionUpdateInput!, where: ProductTransactionWhereUniqueInput!): ProductTransaction!
  upsertOneRole(create: RoleCreateInput!, update: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  upsertOneSize(create: SizeCreateInput!, update: SizeUpdateInput!, where: SizeWhereUniqueInput!): Size!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Product {
  _count: ProductCount
  cost: Float!
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  name: String!
  productSales(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
  productTransactions(cursor: ProductTransactionWhereUniqueInput, distinct: [ProductTransactionScalarFieldEnum!], orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): [ProductTransaction!]!
  rating: Float!
}

type ProductAvgAggregate {
  cost: Float
  rating: Float
}

input ProductAvgOrderByAggregateInput {
  cost: SortOrder
  rating: SortOrder
}

type ProductCount {
  inventory: Int!
  productSales: Int!
  productTransactions: Int!
}

type ProductCountAggregate {
  _all: Int!
  cost: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
  rating: Int!
}

input ProductCountOrderByAggregateInput {
  cost: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
}

input ProductCreateInput {
  cost: Float!
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutProductInput
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutProductInput
  productTransactions: ProductTransactionCreateNestedManyWithoutProductInput
  rating: Float!
}

input ProductCreateNestedOneWithoutInventoryInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
}

input ProductCreateNestedOneWithoutProductSalesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSalesInput
  create: ProductCreateWithoutProductSalesInput
}

input ProductCreateNestedOneWithoutProductTransactionsInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductTransactionsInput
  create: ProductCreateWithoutProductTransactionsInput
}

input ProductCreateOrConnectWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductSalesInput {
  create: ProductCreateWithoutProductSalesInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductTransactionsInput {
  create: ProductCreateWithoutProductTransactionsInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutInventoryInput {
  cost: Float!
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutProductInput
  productTransactions: ProductTransactionCreateNestedManyWithoutProductInput
  rating: Float!
}

input ProductCreateWithoutProductSalesInput {
  cost: Float!
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutProductInput
  name: String!
  productTransactions: ProductTransactionCreateNestedManyWithoutProductInput
  rating: Float!
}

input ProductCreateWithoutProductTransactionsInput {
  cost: Float!
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutProductInput
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutProductInput
  rating: Float!
}

type ProductGroupBy {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
  cost: Float!
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
  rating: Float!
}

type ProductMaxAggregate {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  rating: Float
}

input ProductMaxOrderByAggregateInput {
  cost: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
}

type ProductMinAggregate {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  rating: Float
}

input ProductMinOrderByAggregateInput {
  cost: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
}

input ProductOrderByWithAggregationInput {
  _avg: ProductAvgOrderByAggregateInput
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  _sum: ProductSumOrderByAggregateInput
  cost: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
}

input ProductOrderByWithRelationInput {
  cost: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  inventory: InventoryOrderByRelationAggregateInput
  name: SortOrder
  productSales: ProductSaleOrderByRelationAggregateInput
  productTransactions: ProductTransactionOrderByRelationAggregateInput
  rating: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

type ProductSale {
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: Size!
  sizeId: String!
}

type ProductSaleAvgAggregate {
  quantity: Float
}

input ProductSaleAvgOrderByAggregateInput {
  quantity: SortOrder
}

type ProductSaleCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
  quantity: Int!
  sizeId: Int!
}

input ProductSaleCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutProductSalesInput!
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductSalesInput!
}

input ProductSaleCreateNestedManyWithoutProductInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutProductInput!]
  create: [ProductSaleCreateWithoutProductInput!]
}

input ProductSaleCreateNestedManyWithoutSizeInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutSizeInput!]
  create: [ProductSaleCreateWithoutSizeInput!]
}

input ProductSaleCreateOrConnectWithoutProductInput {
  create: ProductSaleCreateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleCreateOrConnectWithoutSizeInput {
  create: ProductSaleCreateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleCreateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductSalesInput!
}

input ProductSaleCreateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductCreateNestedOneWithoutProductSalesInput!
  quantity: Int!
}

type ProductSaleGroupBy {
  _avg: ProductSaleAvgAggregate
  _count: ProductSaleCountAggregate
  _max: ProductSaleMaxAggregate
  _min: ProductSaleMinAggregate
  _sum: ProductSaleSumAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  productId: String!
  quantity: Int!
  sizeId: String!
}

input ProductSaleListRelationFilter {
  every: ProductSaleWhereInput
  none: ProductSaleWhereInput
  some: ProductSaleWhereInput
}

type ProductSaleMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input ProductSaleMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

type ProductSaleMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  productId: String
  quantity: Int
  sizeId: String
}

input ProductSaleMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductSaleOrderByWithAggregationInput {
  _avg: ProductSaleAvgOrderByAggregateInput
  _count: ProductSaleCountOrderByAggregateInput
  _max: ProductSaleMaxOrderByAggregateInput
  _min: ProductSaleMinOrderByAggregateInput
  _sum: ProductSaleSumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductSaleOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SizeOrderByWithRelationInput
  sizeId: SortOrder
}

enum ProductSaleScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  productId
  quantity
  sizeId
}

input ProductSaleScalarWhereInput {
  AND: [ProductSaleScalarWhereInput!]
  NOT: [ProductSaleScalarWhereInput!]
  OR: [ProductSaleScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  productId: StringFilter
  quantity: IntFilter
  sizeId: StringFilter
}

input ProductSaleScalarWhereWithAggregatesInput {
  AND: [ProductSaleScalarWhereWithAggregatesInput!]
  NOT: [ProductSaleScalarWhereWithAggregatesInput!]
  OR: [ProductSaleScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  sizeId: StringWithAggregatesFilter
}

type ProductSaleSumAggregate {
  quantity: Int
}

input ProductSaleSumOrderByAggregateInput {
  quantity: SortOrder
}

input ProductSaleUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutProductSalesNestedInput
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductSalesNestedInput
}

input ProductSaleUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
}

input ProductSaleUpdateManyWithWhereWithoutProductInput {
  data: ProductSaleUpdateManyMutationInput!
  where: ProductSaleScalarWhereInput!
}

input ProductSaleUpdateManyWithWhereWithoutSizeInput {
  data: ProductSaleUpdateManyMutationInput!
  where: ProductSaleScalarWhereInput!
}

input ProductSaleUpdateManyWithoutProductNestedInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutProductInput!]
  create: [ProductSaleCreateWithoutProductInput!]
  delete: [ProductSaleWhereUniqueInput!]
  deleteMany: [ProductSaleScalarWhereInput!]
  disconnect: [ProductSaleWhereUniqueInput!]
  set: [ProductSaleWhereUniqueInput!]
  update: [ProductSaleUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductSaleUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductSaleUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductSaleUpdateManyWithoutSizeNestedInput {
  connect: [ProductSaleWhereUniqueInput!]
  connectOrCreate: [ProductSaleCreateOrConnectWithoutSizeInput!]
  create: [ProductSaleCreateWithoutSizeInput!]
  delete: [ProductSaleWhereUniqueInput!]
  deleteMany: [ProductSaleScalarWhereInput!]
  disconnect: [ProductSaleWhereUniqueInput!]
  set: [ProductSaleWhereUniqueInput!]
  update: [ProductSaleUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [ProductSaleUpdateManyWithWhereWithoutSizeInput!]
  upsert: [ProductSaleUpsertWithWhereUniqueWithoutSizeInput!]
}

input ProductSaleUpdateWithWhereUniqueWithoutProductInput {
  data: ProductSaleUpdateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpdateWithWhereUniqueWithoutSizeInput {
  data: ProductSaleUpdateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpdateWithoutProductInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductSalesNestedInput
}

input ProductSaleUpdateWithoutSizeInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  product: ProductUpdateOneRequiredWithoutProductSalesNestedInput
  quantity: Int
}

input ProductSaleUpsertWithWhereUniqueWithoutProductInput {
  create: ProductSaleCreateWithoutProductInput!
  update: ProductSaleUpdateWithoutProductInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleUpsertWithWhereUniqueWithoutSizeInput {
  create: ProductSaleCreateWithoutSizeInput!
  update: ProductSaleUpdateWithoutSizeInput!
  where: ProductSaleWhereUniqueInput!
}

input ProductSaleWhereInput {
  AND: [ProductSaleWhereInput!]
  NOT: [ProductSaleWhereInput!]
  OR: [ProductSaleWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: SizeRelationFilter
  sizeId: StringFilter
}

input ProductSaleWhereUniqueInput {
  id: String
}

enum ProductScalarFieldEnum {
  cost
  dateCreated
  dateUpdated
  id
  name
  rating
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  cost: FloatWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  rating: FloatWithAggregatesFilter
}

type ProductSumAggregate {
  cost: Float
  rating: Float
}

input ProductSumOrderByAggregateInput {
  cost: SortOrder
  rating: SortOrder
}

type ProductTransaction {
  dateCreated: DateTime!
  id: String!
  price: Float!
  product: Product!
  productId: String!
  quantity: Int!
  size: Size!
  sizeId: String!
}

type ProductTransactionAvgAggregate {
  price: Float
  quantity: Float
}

input ProductTransactionAvgOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

type ProductTransactionCountAggregate {
  _all: Int!
  dateCreated: Int!
  id: Int!
  price: Int!
  productId: Int!
  quantity: Int!
  sizeId: Int!
}

input ProductTransactionCountOrderByAggregateInput {
  dateCreated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductTransactionCreateInput {
  dateCreated: DateTime
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutProductTransactionsInput!
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductTransactionsInput!
}

input ProductTransactionCreateNestedManyWithoutProductInput {
  connect: [ProductTransactionWhereUniqueInput!]
  connectOrCreate: [ProductTransactionCreateOrConnectWithoutProductInput!]
  create: [ProductTransactionCreateWithoutProductInput!]
}

input ProductTransactionCreateNestedManyWithoutSizeInput {
  connect: [ProductTransactionWhereUniqueInput!]
  connectOrCreate: [ProductTransactionCreateOrConnectWithoutSizeInput!]
  create: [ProductTransactionCreateWithoutSizeInput!]
}

input ProductTransactionCreateOrConnectWithoutProductInput {
  create: ProductTransactionCreateWithoutProductInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionCreateOrConnectWithoutSizeInput {
  create: ProductTransactionCreateWithoutSizeInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionCreateWithoutProductInput {
  dateCreated: DateTime
  id: String
  price: Float!
  quantity: Int!
  size: SizeCreateNestedOneWithoutProductTransactionsInput!
}

input ProductTransactionCreateWithoutSizeInput {
  dateCreated: DateTime
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutProductTransactionsInput!
  quantity: Int!
}

type ProductTransactionGroupBy {
  _avg: ProductTransactionAvgAggregate
  _count: ProductTransactionCountAggregate
  _max: ProductTransactionMaxAggregate
  _min: ProductTransactionMinAggregate
  _sum: ProductTransactionSumAggregate
  dateCreated: DateTime!
  id: String!
  price: Float!
  productId: String!
  quantity: Int!
  sizeId: String!
}

input ProductTransactionListRelationFilter {
  every: ProductTransactionWhereInput
  none: ProductTransactionWhereInput
  some: ProductTransactionWhereInput
}

type ProductTransactionMaxAggregate {
  dateCreated: DateTime
  id: String
  price: Float
  productId: String
  quantity: Int
  sizeId: String
}

input ProductTransactionMaxOrderByAggregateInput {
  dateCreated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

type ProductTransactionMinAggregate {
  dateCreated: DateTime
  id: String
  price: Float
  productId: String
  quantity: Int
  sizeId: String
}

input ProductTransactionMinOrderByAggregateInput {
  dateCreated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductTransactionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductTransactionOrderByWithAggregationInput {
  _avg: ProductTransactionAvgOrderByAggregateInput
  _count: ProductTransactionCountOrderByAggregateInput
  _max: ProductTransactionMaxOrderByAggregateInput
  _min: ProductTransactionMinOrderByAggregateInput
  _sum: ProductTransactionSumOrderByAggregateInput
  dateCreated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  sizeId: SortOrder
}

input ProductTransactionOrderByWithRelationInput {
  dateCreated: SortOrder
  id: SortOrder
  price: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SizeOrderByWithRelationInput
  sizeId: SortOrder
}

enum ProductTransactionScalarFieldEnum {
  dateCreated
  id
  price
  productId
  quantity
  sizeId
}

input ProductTransactionScalarWhereInput {
  AND: [ProductTransactionScalarWhereInput!]
  NOT: [ProductTransactionScalarWhereInput!]
  OR: [ProductTransactionScalarWhereInput!]
  dateCreated: DateTimeFilter
  id: StringFilter
  price: FloatFilter
  productId: StringFilter
  quantity: IntFilter
  sizeId: StringFilter
}

input ProductTransactionScalarWhereWithAggregatesInput {
  AND: [ProductTransactionScalarWhereWithAggregatesInput!]
  NOT: [ProductTransactionScalarWhereWithAggregatesInput!]
  OR: [ProductTransactionScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  sizeId: StringWithAggregatesFilter
}

type ProductTransactionSumAggregate {
  price: Float
  quantity: Int
}

input ProductTransactionSumOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

input ProductTransactionUpdateInput {
  dateCreated: DateTime
  id: String
  price: Float
  product: ProductUpdateOneRequiredWithoutProductTransactionsNestedInput
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductTransactionsNestedInput
}

input ProductTransactionUpdateManyMutationInput {
  dateCreated: DateTime
  id: String
  price: Float
  quantity: Int
}

input ProductTransactionUpdateManyWithWhereWithoutProductInput {
  data: ProductTransactionUpdateManyMutationInput!
  where: ProductTransactionScalarWhereInput!
}

input ProductTransactionUpdateManyWithWhereWithoutSizeInput {
  data: ProductTransactionUpdateManyMutationInput!
  where: ProductTransactionScalarWhereInput!
}

input ProductTransactionUpdateManyWithoutProductNestedInput {
  connect: [ProductTransactionWhereUniqueInput!]
  connectOrCreate: [ProductTransactionCreateOrConnectWithoutProductInput!]
  create: [ProductTransactionCreateWithoutProductInput!]
  delete: [ProductTransactionWhereUniqueInput!]
  deleteMany: [ProductTransactionScalarWhereInput!]
  disconnect: [ProductTransactionWhereUniqueInput!]
  set: [ProductTransactionWhereUniqueInput!]
  update: [ProductTransactionUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductTransactionUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductTransactionUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductTransactionUpdateManyWithoutSizeNestedInput {
  connect: [ProductTransactionWhereUniqueInput!]
  connectOrCreate: [ProductTransactionCreateOrConnectWithoutSizeInput!]
  create: [ProductTransactionCreateWithoutSizeInput!]
  delete: [ProductTransactionWhereUniqueInput!]
  deleteMany: [ProductTransactionScalarWhereInput!]
  disconnect: [ProductTransactionWhereUniqueInput!]
  set: [ProductTransactionWhereUniqueInput!]
  update: [ProductTransactionUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [ProductTransactionUpdateManyWithWhereWithoutSizeInput!]
  upsert: [ProductTransactionUpsertWithWhereUniqueWithoutSizeInput!]
}

input ProductTransactionUpdateWithWhereUniqueWithoutProductInput {
  data: ProductTransactionUpdateWithoutProductInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionUpdateWithWhereUniqueWithoutSizeInput {
  data: ProductTransactionUpdateWithoutSizeInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionUpdateWithoutProductInput {
  dateCreated: DateTime
  id: String
  price: Float
  quantity: Int
  size: SizeUpdateOneRequiredWithoutProductTransactionsNestedInput
}

input ProductTransactionUpdateWithoutSizeInput {
  dateCreated: DateTime
  id: String
  price: Float
  product: ProductUpdateOneRequiredWithoutProductTransactionsNestedInput
  quantity: Int
}

input ProductTransactionUpsertWithWhereUniqueWithoutProductInput {
  create: ProductTransactionCreateWithoutProductInput!
  update: ProductTransactionUpdateWithoutProductInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionUpsertWithWhereUniqueWithoutSizeInput {
  create: ProductTransactionCreateWithoutSizeInput!
  update: ProductTransactionUpdateWithoutSizeInput!
  where: ProductTransactionWhereUniqueInput!
}

input ProductTransactionWhereInput {
  AND: [ProductTransactionWhereInput!]
  NOT: [ProductTransactionWhereInput!]
  OR: [ProductTransactionWhereInput!]
  dateCreated: DateTimeFilter
  id: StringFilter
  price: FloatFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: SizeRelationFilter
  sizeId: StringFilter
}

input ProductTransactionWhereUniqueInput {
  id: String
}

input ProductUpdateInput {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutProductNestedInput
  name: String
  productSales: ProductSaleUpdateManyWithoutProductNestedInput
  productTransactions: ProductTransactionUpdateManyWithoutProductNestedInput
  rating: Float
}

input ProductUpdateManyMutationInput {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  rating: Float
}

input ProductUpdateOneRequiredWithoutInventoryNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
  update: ProductUpdateWithoutInventoryInput
  upsert: ProductUpsertWithoutInventoryInput
}

input ProductUpdateOneRequiredWithoutProductSalesNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSalesInput
  create: ProductCreateWithoutProductSalesInput
  update: ProductUpdateWithoutProductSalesInput
  upsert: ProductUpsertWithoutProductSalesInput
}

input ProductUpdateOneRequiredWithoutProductTransactionsNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductTransactionsInput
  create: ProductCreateWithoutProductTransactionsInput
  update: ProductUpdateWithoutProductTransactionsInput
  upsert: ProductUpsertWithoutProductTransactionsInput
}

input ProductUpdateWithoutInventoryInput {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  productSales: ProductSaleUpdateManyWithoutProductNestedInput
  productTransactions: ProductTransactionUpdateManyWithoutProductNestedInput
  rating: Float
}

input ProductUpdateWithoutProductSalesInput {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutProductNestedInput
  name: String
  productTransactions: ProductTransactionUpdateManyWithoutProductNestedInput
  rating: Float
}

input ProductUpdateWithoutProductTransactionsInput {
  cost: Float
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutProductNestedInput
  name: String
  productSales: ProductSaleUpdateManyWithoutProductNestedInput
  rating: Float
}

input ProductUpsertWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  update: ProductUpdateWithoutInventoryInput!
}

input ProductUpsertWithoutProductSalesInput {
  create: ProductCreateWithoutProductSalesInput!
  update: ProductUpdateWithoutProductSalesInput!
}

input ProductUpsertWithoutProductTransactionsInput {
  create: ProductCreateWithoutProductTransactionsInput!
  update: ProductUpdateWithoutProductTransactionsInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  cost: FloatFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  inventory: InventoryListRelationFilter
  name: StringFilter
  productSales: ProductSaleListRelationFilter
  productTransactions: ProductTransactionListRelationFilter
  rating: FloatFilter
}

input ProductWhereUniqueInput {
  id: String
  name: String
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateDepartment(cursor: DepartmentWhereUniqueInput, orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): AggregateDepartment!
  aggregateEmployee(cursor: EmployeeWhereUniqueInput, orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): AggregateEmployee!
  aggregateInventory(cursor: InventoryWhereUniqueInput, orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): AggregateInventory!
  aggregateLocationState(cursor: LocationStateWhereUniqueInput, orderBy: [LocationStateOrderByWithRelationInput!], skip: Int, take: Int, where: LocationStateWhereInput): AggregateLocationState!
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateProductSale(cursor: ProductSaleWhereUniqueInput, orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): AggregateProductSale!
  aggregateProductTransaction(cursor: ProductTransactionWhereUniqueInput, orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): AggregateProductTransaction!
  aggregateRole(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): AggregateRole!
  aggregateSize(cursor: SizeWhereUniqueInput, orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): AggregateSize!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [Department!]!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstDepartment(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstDepartmentOrThrow(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstEmployee(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstEmployeeOrThrow(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstInventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstInventoryOrThrow(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstLocationState(cursor: LocationStateWhereUniqueInput, distinct: [LocationStateScalarFieldEnum!], orderBy: [LocationStateOrderByWithRelationInput!], skip: Int, take: Int, where: LocationStateWhereInput): LocationState
  findFirstLocationStateOrThrow(cursor: LocationStateWhereUniqueInput, distinct: [LocationStateScalarFieldEnum!], orderBy: [LocationStateOrderByWithRelationInput!], skip: Int, take: Int, where: LocationStateWhereInput): LocationState
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductOrThrow(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductSale(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): ProductSale
  findFirstProductSaleOrThrow(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): ProductSale
  findFirstProductTransaction(cursor: ProductTransactionWhereUniqueInput, distinct: [ProductTransactionScalarFieldEnum!], orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): ProductTransaction
  findFirstProductTransactionOrThrow(cursor: ProductTransactionWhereUniqueInput, distinct: [ProductTransactionScalarFieldEnum!], orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): ProductTransaction
  findFirstRole(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstRoleOrThrow(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstSize(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): Size
  findFirstSizeOrThrow(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): Size
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getDepartment(where: DepartmentWhereUniqueInput!): Department
  getEmployee(where: EmployeeWhereUniqueInput!): Employee
  getInventory(where: InventoryWhereUniqueInput!): Inventory
  getLocationState(where: LocationStateWhereUniqueInput!): LocationState
  getProduct(where: ProductWhereUniqueInput!): Product
  getProductSale(where: ProductSaleWhereUniqueInput!): ProductSale
  getProductTransaction(where: ProductTransactionWhereUniqueInput!): ProductTransaction
  getRole(where: RoleWhereUniqueInput!): Role
  getSize(where: SizeWhereUniqueInput!): Size
  getUser(where: UserWhereUniqueInput!): User
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByDepartment(by: [DepartmentScalarFieldEnum!]!, having: DepartmentScalarWhereWithAggregatesInput, orderBy: [DepartmentOrderByWithAggregationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [DepartmentGroupBy!]!
  groupByEmployee(by: [EmployeeScalarFieldEnum!]!, having: EmployeeScalarWhereWithAggregatesInput, orderBy: [EmployeeOrderByWithAggregationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [EmployeeGroupBy!]!
  groupByInventory(by: [InventoryScalarFieldEnum!]!, having: InventoryScalarWhereWithAggregatesInput, orderBy: [InventoryOrderByWithAggregationInput!], skip: Int, take: Int, where: InventoryWhereInput): [InventoryGroupBy!]!
  groupByLocationState(by: [LocationStateScalarFieldEnum!]!, having: LocationStateScalarWhereWithAggregatesInput, orderBy: [LocationStateOrderByWithAggregationInput!], skip: Int, take: Int, where: LocationStateWhereInput): [LocationStateGroupBy!]!
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByProductSale(by: [ProductSaleScalarFieldEnum!]!, having: ProductSaleScalarWhereWithAggregatesInput, orderBy: [ProductSaleOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSaleGroupBy!]!
  groupByProductTransaction(by: [ProductTransactionScalarFieldEnum!]!, having: ProductTransactionScalarWhereWithAggregatesInput, orderBy: [ProductTransactionOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): [ProductTransactionGroupBy!]!
  groupByRole(by: [RoleScalarFieldEnum!]!, having: RoleScalarWhereWithAggregatesInput, orderBy: [RoleOrderByWithAggregationInput!], skip: Int, take: Int, where: RoleWhereInput): [RoleGroupBy!]!
  groupBySize(by: [SizeScalarFieldEnum!]!, having: SizeScalarWhereWithAggregatesInput, orderBy: [SizeOrderByWithAggregationInput!], skip: Int, take: Int, where: SizeWhereInput): [SizeGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  inventories(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  locationState(where: LocationStateWhereUniqueInput!): LocationState
  locationStates(cursor: LocationStateWhereUniqueInput, distinct: [LocationStateScalarFieldEnum!], orderBy: [LocationStateOrderByWithRelationInput!], skip: Int, take: Int, where: LocationStateWhereInput): [LocationState!]!
  product(where: ProductWhereUniqueInput!): Product
  productSale(where: ProductSaleWhereUniqueInput!): ProductSale
  productSales(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
  productTransaction(where: ProductTransactionWhereUniqueInput!): ProductTransaction
  productTransactionCountByProductId(productId: String!): String
  productTransactions(cursor: ProductTransactionWhereUniqueInput, distinct: [ProductTransactionScalarFieldEnum!], orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): [ProductTransaction!]!
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  role(where: RoleWhereUniqueInput!): Role
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  size(where: SizeWhereUniqueInput!): Size
  sizes(cursor: SizeWhereUniqueInput, distinct: [SizeScalarFieldEnum!], orderBy: [SizeOrderByWithRelationInput!], skip: Int, take: Int, where: SizeWhereInput): [Size!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Role {
  _count: RoleCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  description: Int!
  id: Int!
  name: Int!
}

input RoleCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
  users: UserCreateNestedManyWithoutRoleInput
}

input RoleCreateNestedOneWithoutUsersInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
}

type RoleGroupBy {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
}

type RoleMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

type RoleMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithAggregationInput {
  _count: RoleCountOrderByAggregateInput
  _max: RoleMaxOrderByAggregateInput
  _min: RoleMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  users: UserOrderByRelationAggregateInput
}

input RoleRelationFilter {
  is: RoleWhereInput
  isNot: RoleWhereInput
}

enum RoleScalarFieldEnum {
  dateCreated
  dateUpdated
  description
  id
  name
}

input RoleScalarWhereWithAggregatesInput {
  AND: [RoleScalarWhereWithAggregatesInput!]
  NOT: [RoleScalarWhereWithAggregatesInput!]
  OR: [RoleScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input RoleUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
  users: UserUpdateManyWithoutRoleNestedInput
}

input RoleUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpdateOneRequiredWithoutUsersNestedInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
  update: RoleUpdateWithoutUsersInput
  upsert: RoleUpsertWithoutUsersInput
}

input RoleUpdateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpsertWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  update: RoleUpdateWithoutUsersInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

type Size {
  _count: SizeCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  name: String!
  productSales(cursor: ProductSaleWhereUniqueInput, distinct: [ProductSaleScalarFieldEnum!], orderBy: [ProductSaleOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSaleWhereInput): [ProductSale!]!
  productTransactions(cursor: ProductTransactionWhereUniqueInput, distinct: [ProductTransactionScalarFieldEnum!], orderBy: [ProductTransactionOrderByWithRelationInput!], skip: Int, take: Int, where: ProductTransactionWhereInput): [ProductTransaction!]!
}

type SizeCount {
  inventory: Int!
  productSales: Int!
  productTransactions: Int!
}

type SizeCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input SizeCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutSizeInput
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutSizeInput
  productTransactions: ProductTransactionCreateNestedManyWithoutSizeInput
}

input SizeCreateNestedOneWithoutInventoryInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutInventoryInput
  create: SizeCreateWithoutInventoryInput
}

input SizeCreateNestedOneWithoutProductSalesInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductSalesInput
  create: SizeCreateWithoutProductSalesInput
}

input SizeCreateNestedOneWithoutProductTransactionsInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductTransactionsInput
  create: SizeCreateWithoutProductTransactionsInput
}

input SizeCreateOrConnectWithoutInventoryInput {
  create: SizeCreateWithoutInventoryInput!
  where: SizeWhereUniqueInput!
}

input SizeCreateOrConnectWithoutProductSalesInput {
  create: SizeCreateWithoutProductSalesInput!
  where: SizeWhereUniqueInput!
}

input SizeCreateOrConnectWithoutProductTransactionsInput {
  create: SizeCreateWithoutProductTransactionsInput!
  where: SizeWhereUniqueInput!
}

input SizeCreateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutSizeInput
  productTransactions: ProductTransactionCreateNestedManyWithoutSizeInput
}

input SizeCreateWithoutProductSalesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutSizeInput
  name: String!
  productTransactions: ProductTransactionCreateNestedManyWithoutSizeInput
}

input SizeCreateWithoutProductTransactionsInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryCreateNestedManyWithoutSizeInput
  name: String!
  productSales: ProductSaleCreateNestedManyWithoutSizeInput
}

type SizeGroupBy {
  _count: SizeCountAggregate
  _max: SizeMaxAggregate
  _min: SizeMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type SizeMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type SizeMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeOrderByWithAggregationInput {
  _count: SizeCountOrderByAggregateInput
  _max: SizeMaxOrderByAggregateInput
  _min: SizeMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input SizeOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  inventory: InventoryOrderByRelationAggregateInput
  name: SortOrder
  productSales: ProductSaleOrderByRelationAggregateInput
  productTransactions: ProductTransactionOrderByRelationAggregateInput
}

input SizeRelationFilter {
  is: SizeWhereInput
  isNot: SizeWhereInput
}

enum SizeScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input SizeScalarWhereWithAggregatesInput {
  AND: [SizeScalarWhereWithAggregatesInput!]
  NOT: [SizeScalarWhereWithAggregatesInput!]
  OR: [SizeScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input SizeUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutSizeNestedInput
  name: String
  productSales: ProductSaleUpdateManyWithoutSizeNestedInput
  productTransactions: ProductTransactionUpdateManyWithoutSizeNestedInput
}

input SizeUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input SizeUpdateOneRequiredWithoutInventoryNestedInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutInventoryInput
  create: SizeCreateWithoutInventoryInput
  update: SizeUpdateWithoutInventoryInput
  upsert: SizeUpsertWithoutInventoryInput
}

input SizeUpdateOneRequiredWithoutProductSalesNestedInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductSalesInput
  create: SizeCreateWithoutProductSalesInput
  update: SizeUpdateWithoutProductSalesInput
  upsert: SizeUpsertWithoutProductSalesInput
}

input SizeUpdateOneRequiredWithoutProductTransactionsNestedInput {
  connect: SizeWhereUniqueInput
  connectOrCreate: SizeCreateOrConnectWithoutProductTransactionsInput
  create: SizeCreateWithoutProductTransactionsInput
  update: SizeUpdateWithoutProductTransactionsInput
  upsert: SizeUpsertWithoutProductTransactionsInput
}

input SizeUpdateWithoutInventoryInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
  productSales: ProductSaleUpdateManyWithoutSizeNestedInput
  productTransactions: ProductTransactionUpdateManyWithoutSizeNestedInput
}

input SizeUpdateWithoutProductSalesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutSizeNestedInput
  name: String
  productTransactions: ProductTransactionUpdateManyWithoutSizeNestedInput
}

input SizeUpdateWithoutProductTransactionsInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  inventory: InventoryUpdateManyWithoutSizeNestedInput
  name: String
  productSales: ProductSaleUpdateManyWithoutSizeNestedInput
}

input SizeUpsertWithoutInventoryInput {
  create: SizeCreateWithoutInventoryInput!
  update: SizeUpdateWithoutInventoryInput!
}

input SizeUpsertWithoutProductSalesInput {
  create: SizeCreateWithoutProductSalesInput!
  update: SizeUpdateWithoutProductSalesInput!
}

input SizeUpsertWithoutProductTransactionsInput {
  create: SizeCreateWithoutProductTransactionsInput!
  update: SizeUpdateWithoutProductTransactionsInput!
}

input SizeWhereInput {
  AND: [SizeWhereInput!]
  NOT: [SizeWhereInput!]
  OR: [SizeWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  id: StringFilter
  inventory: InventoryListRelationFilter
  name: StringFilter
  productSales: ProductSaleListRelationFilter
  productTransactions: ProductTransactionListRelationFilter
}

input SizeWhereUniqueInput {
  id: String
  name: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  role: Role!
  roleId: String!
  userName: String!
}

type UserCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  roleId: Int!
  userName: Int!
}

input UserCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: RoleCreateNestedOneWithoutUsersInput!
  userName: String!
}

input UserCreateNestedManyWithoutRoleInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
}

input UserCreateOrConnectWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  userName: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  roleId: String!
  userName: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

type UserMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: RoleOrderByWithRelationInput
  roleId: SortOrder
  userName: SortOrder
}

enum UserScalarFieldEnum {
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  password
  roleId
  userName
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  roleId: StringWithAggregatesFilter
  userName: StringWithAggregatesFilter
}

input UserUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: RoleUpdateOneRequiredWithoutUsersNestedInput
  userName: String
}

input UserUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpdateManyWithWhereWithoutRoleInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutRoleNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [UserUpdateManyWithWhereWithoutRoleInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserUpdateWithWhereUniqueWithoutRoleInput {
  data: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpsertWithWhereUniqueWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  update: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  role: RoleRelationFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  userName: String
}