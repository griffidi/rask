# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateDepartment {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
}

type AggregateEmployee {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
}

type AggregateRole {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Customer {
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerCountAggregate {
  _all: Int!
  city: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
  state: Int!
  streetAddress: Int!
  zipCode: Int!
}

input CustomerCountOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerCreateInput {
  city: String!
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  city: String!
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type CustomerMaxAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerMaxOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type CustomerMinAggregate {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerMinOrderByAggregateInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input CustomerOrderByWithRelationInput {
  city: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum CustomerScalarFieldEnum {
  city
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
  state
  streetAddress
  zipCode
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  state: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerUpdateManyMutationInput {
  city: String
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  city: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input CustomerWhereUniqueInput {
  email: String
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Department {
  _count: DepartmentCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  id: String!
  name: String!
}

type DepartmentCount {
  employees: Int!
}

type DepartmentCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input DepartmentCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeCreateNestedManyWithoutDepartmentInput
  id: String
  name: String!
}

input DepartmentCreateNestedOneWithoutEmployeesInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
}

input DepartmentCreateOrConnectWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  where: DepartmentWhereUniqueInput!
}

input DepartmentCreateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String!
}

type DepartmentGroupBy {
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  id: String!
  name: String!
}

type DepartmentMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type DepartmentMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithAggregationInput {
  _count: DepartmentCountOrderByAggregateInput
  _max: DepartmentMaxOrderByAggregateInput
  _min: DepartmentMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  employees: EmployeeOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

input DepartmentRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

enum DepartmentScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input DepartmentScalarWhereWithAggregatesInput {
  AND: [DepartmentScalarWhereWithAggregatesInput!]
  NOT: [DepartmentScalarWhereWithAggregatesInput!]
  OR: [DepartmentScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input DepartmentUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  employees: EmployeeUpdateManyWithoutDepartmentNestedInput
  id: String
  name: String
}

input DepartmentUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpdateOneRequiredWithoutEmployeesNestedInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutEmployeesInput
  create: DepartmentCreateWithoutEmployeesInput
  update: DepartmentUpdateWithoutEmployeesInput
  upsert: DepartmentUpsertWithoutEmployeesInput
}

input DepartmentUpdateWithoutEmployeesInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  id: String
  name: String
}

input DepartmentUpsertWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  update: DepartmentUpdateWithoutEmployeesInput!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  employees: EmployeeListRelationFilter
  id: StringFilter
  name: StringFilter
}

input DepartmentWhereUniqueInput {
  id: String
  name: String
}

type Employee {
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  department: Department!
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeCountAggregate {
  _all: Int!
  city: Int!
  dateStarted: Int!
  dateUpdated: Int!
  departmentId: Int!
  email: Int!
  firstName: Int!
  gender: Int!
  id: Int!
  jobTitle: Int!
  lastName: Int!
  phone: Int!
  state: Int!
  streetAddress: Int!
  zipCode: Int!
}

input EmployeeCountOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeCreateInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentCreateNestedOneWithoutEmployeesInput!
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeCreateNestedManyWithoutDepartmentInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
}

input EmployeeCreateOrConnectWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeCreateWithoutDepartmentInput {
  city: String!
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  gender: String!
  id: String
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

type EmployeeGroupBy {
  _count: EmployeeCountAggregate
  _max: EmployeeMaxAggregate
  _min: EmployeeMinAggregate
  city: String!
  dateStarted: DateTime!
  dateUpdated: DateTime
  departmentId: String!
  email: String!
  firstName: String!
  gender: String!
  id: String!
  jobTitle: String!
  lastName: String!
  phone: String!
  state: String!
  streetAddress: String!
  zipCode: String!
}

input EmployeeListRelationFilter {
  every: EmployeeWhereInput
  none: EmployeeWhereInput
  some: EmployeeWhereInput
}

type EmployeeMaxAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeMaxOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

type EmployeeMinAggregate {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  departmentId: String
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeMinOrderByAggregateInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByRelationAggregateInput {
  _count: SortOrder
}

input EmployeeOrderByWithAggregationInput {
  _count: EmployeeCountOrderByAggregateInput
  _max: EmployeeMaxOrderByAggregateInput
  _min: EmployeeMinOrderByAggregateInput
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

input EmployeeOrderByWithRelationInput {
  city: SortOrder
  dateStarted: SortOrder
  dateUpdated: SortOrder
  department: DepartmentOrderByWithRelationInput
  departmentId: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  jobTitle: SortOrder
  lastName: SortOrder
  phone: SortOrder
  state: SortOrder
  streetAddress: SortOrder
  zipCode: SortOrder
}

enum EmployeeScalarFieldEnum {
  city
  dateStarted
  dateUpdated
  departmentId
  email
  firstName
  gender
  id
  jobTitle
  lastName
  phone
  state
  streetAddress
  zipCode
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput!]
  NOT: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeScalarWhereWithAggregatesInput {
  AND: [EmployeeScalarWhereWithAggregatesInput!]
  NOT: [EmployeeScalarWhereWithAggregatesInput!]
  OR: [EmployeeScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  dateStarted: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  departmentId: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  jobTitle: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  state: StringWithAggregatesFilter
  streetAddress: StringWithAggregatesFilter
  zipCode: StringWithAggregatesFilter
}

input EmployeeUpdateInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  department: DepartmentUpdateOneRequiredWithoutEmployeesNestedInput
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyMutationInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpdateManyWithWhereWithoutDepartmentInput {
  data: EmployeeUpdateManyMutationInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateManyWithoutDepartmentNestedInput {
  connect: [EmployeeWhereUniqueInput!]
  connectOrCreate: [EmployeeCreateOrConnectWithoutDepartmentInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutDepartmentInput!]
  updateMany: [EmployeeUpdateManyWithWhereWithoutDepartmentInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutDepartmentInput!]
}

input EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  data: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithoutDepartmentInput {
  city: String
  dateStarted: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  gender: String
  id: String
  jobTitle: String
  lastName: String
  phone: String
  state: String
  streetAddress: String
  zipCode: String
}

input EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  update: EmployeeUpdateWithoutDepartmentInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  city: StringFilter
  dateStarted: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  department: DepartmentRelationFilter
  departmentId: StringFilter
  email: StringFilter
  firstName: StringFilter
  gender: StringFilter
  id: StringFilter
  jobTitle: StringFilter
  lastName: StringFilter
  phone: StringFilter
  state: StringFilter
  streetAddress: StringFilter
  zipCode: StringFilter
}

input EmployeeWhereUniqueInput {
  email: String
  id: String
}

type Mutation {
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneDepartment(data: DepartmentCreateInput!): Department!
  createOneEmployee(data: EmployeeCreateInput!): Employee!
  createOneRole(data: RoleCreateInput!): Role!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyDepartment(where: DepartmentWhereInput): AffectedRowsOutput!
  deleteManyEmployee(where: EmployeeWhereInput): AffectedRowsOutput!
  deleteManyRole(where: RoleWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteOneEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteOneRole(where: RoleWhereUniqueInput!): Role
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyDepartment(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): AffectedRowsOutput!
  updateManyEmployee(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): AffectedRowsOutput!
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateOneEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneDepartment(create: DepartmentCreateInput!, update: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department!
  upsertOneEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOneRole(create: RoleCreateInput!, update: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateDepartment(cursor: DepartmentWhereUniqueInput, orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): AggregateDepartment!
  aggregateEmployee(cursor: EmployeeWhereUniqueInput, orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): AggregateEmployee!
  aggregateRole(cursor: RoleWhereUniqueInput, orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): AggregateRole!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [Department!]!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [Employee!]!
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstDepartment(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstDepartmentOrThrow(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstEmployee(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstEmployeeOrThrow(cursor: EmployeeWhereUniqueInput, distinct: [EmployeeScalarFieldEnum!], orderBy: [EmployeeOrderByWithRelationInput!], skip: Int, take: Int, where: EmployeeWhereInput): Employee
  findFirstRole(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstRoleOrThrow(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): Role
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getDepartment(where: DepartmentWhereUniqueInput!): Department
  getEmployee(where: EmployeeWhereUniqueInput!): Employee
  getRole(where: RoleWhereUniqueInput!): Role
  getUser(where: UserWhereUniqueInput!): User
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByDepartment(by: [DepartmentScalarFieldEnum!]!, having: DepartmentScalarWhereWithAggregatesInput, orderBy: [DepartmentOrderByWithAggregationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [DepartmentGroupBy!]!
  groupByEmployee(by: [EmployeeScalarFieldEnum!]!, having: EmployeeScalarWhereWithAggregatesInput, orderBy: [EmployeeOrderByWithAggregationInput!], skip: Int, take: Int, where: EmployeeWhereInput): [EmployeeGroupBy!]!
  groupByRole(by: [RoleScalarFieldEnum!]!, having: RoleScalarWhereWithAggregatesInput, orderBy: [RoleOrderByWithAggregationInput!], skip: Int, take: Int, where: RoleWhereInput): [RoleGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  login(password: String!, userName: String!): String
  role(where: RoleWhereUniqueInput!): Role
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): [Role!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type Role {
  _count: RoleCount
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  description: Int!
  id: Int!
  name: Int!
}

input RoleCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
  users: UserCreateNestedManyWithoutRoleInput
}

input RoleCreateNestedOneWithoutUsersInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String!
  id: String
  name: String!
}

type RoleGroupBy {
  _count: RoleCountAggregate
  _max: RoleMaxAggregate
  _min: RoleMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  description: String!
  id: String!
  name: String!
}

type RoleMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

type RoleMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithAggregationInput {
  _count: RoleCountOrderByAggregateInput
  _max: RoleMaxOrderByAggregateInput
  _min: RoleMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input RoleOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  users: UserOrderByRelationAggregateInput
}

input RoleRelationFilter {
  is: RoleWhereInput
  isNot: RoleWhereInput
}

enum RoleScalarFieldEnum {
  dateCreated
  dateUpdated
  description
  id
  name
}

input RoleScalarWhereWithAggregatesInput {
  AND: [RoleScalarWhereWithAggregatesInput!]
  NOT: [RoleScalarWhereWithAggregatesInput!]
  OR: [RoleScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input RoleUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
  users: UserUpdateManyWithoutRoleNestedInput
}

input RoleUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpdateOneRequiredWithoutUsersNestedInput {
  connect: RoleWhereUniqueInput
  connectOrCreate: RoleCreateOrConnectWithoutUsersInput
  create: RoleCreateWithoutUsersInput
  update: RoleUpdateWithoutUsersInput
  upsert: RoleUpsertWithoutUsersInput
}

input RoleUpdateWithoutUsersInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  description: String
  id: String
  name: String
}

input RoleUpsertWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  update: RoleUpdateWithoutUsersInput!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  role: Role!
  roleId: String!
  userName: String!
}

type UserCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  roleId: Int!
  userName: Int!
}

input UserCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserCreateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: RoleCreateNestedOneWithoutUsersInput!
  userName: String!
}

input UserCreateNestedManyWithoutRoleInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
}

input UserCreateOrConnectWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  userName: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  dateCreated: DateTime!
  dateUpdated: DateTime
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  roleId: String!
  userName: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

type UserMinAggregate {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  roleId: String
  userName: String
}

input UserMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  roleId: SortOrder
  userName: SortOrder
}

input UserOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: RoleOrderByWithRelationInput
  roleId: SortOrder
  userName: SortOrder
}

enum UserScalarFieldEnum {
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  password
  roleId
  userName
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  roleId: StringWithAggregatesFilter
  userName: StringWithAggregatesFilter
}

input UserUpdateInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: RoleUpdateOneRequiredWithoutUsersNestedInput
  userName: String
}

input UserUpdateManyMutationInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpdateManyWithWhereWithoutRoleInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutRoleNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRoleInput!]
  create: [UserCreateWithoutRoleInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [UserUpdateManyWithWhereWithoutRoleInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserUpdateWithWhereUniqueWithoutRoleInput {
  data: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutRoleInput {
  dateCreated: DateTime
  dateUpdated: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  userName: String
}

input UserUpsertWithWhereUniqueWithoutRoleInput {
  create: UserCreateWithoutRoleInput!
  update: UserUpdateWithoutRoleInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  role: RoleRelationFilter
  roleId: StringFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
  userName: String
}